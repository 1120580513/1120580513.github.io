# Computer Systems

---

## 计算机系统
- `比特(bit)`：0 或 1
- `字节(byte)`： 8个比特
- `字长`： 指明指针数据的标称大小(虚拟地址是以这样一个字来编码的)
- `字`： 总线设定的传送固定字长的字节块
> 32位字长限制虚拟地址空间为0~2^32-1(4GB)、64字长为16EB
- `cpp(预处理器)` `ccl(编译器)` `as(汇编器)` `ld(链接器)`
- `CPU(中央处理单元)` `PC(程序计数器)` `ALU(算术/逻辑单元)` `USB(通用串行总线)`
- `RAM(随机存取存储器)` `DMA(直接存储器存取)` `ROM(只读存储器)(有的即可读也可写)`
- `VA(虚拟地址)` `PTE(页表条目)` `PTEA(页表条目地址)` `PA(物理地址)` `VPN(虚拟页号)`
- `MMU(内存管理单元)` `TLB(翻译后备缓冲器)(虚拟寻址的缓存,每一行保存一个由单个PTE组成的块)`
- `机械原理`： *较大的存储设备要比较小的存储设备运行的慢,而快速设备的造价远高于同类的低速设备*
- `虚拟机`： *对计算机的抽象*

```cpp
#include <stdio.h>

int main()
{
  printf("hello word\n");
  return 0;
}
```
### 源文件到目标文件的过程
1. hello.c *源文件，文本*
2. hello.i *预处理器(cpp)修改原文件(修改#开头的文件)，文本*
3. hello.s *编译器(ccl)将hello.i翻译成hello.s,翻译成汇编语言，文本*
4. hello.o *汇编器(as)将hello.s翻译成机器语言指令并打包成可重定位目标程序的格式，二进制文件*
5. hello *链接器(ld)将程序中的外部函数的预编译的目标文件合并得到可执行程序，二进制文件*

### 硬件组成
 * **总线**： *贯穿整个系统的电子管道，负责在和部件间传递字节信息*
 * **I/O设备**： *系统与外部的联系通道(如：键盘、鼠标 显示器、磁盘)，每个I/O设备都通过一个控制器或适配器与I/O总线相连(控制器是I/O设备本身或主板上的芯片组，适配器则是插在主板上的卡)*
 * **主存**： *临时的存储设备,在处理器执行程序时,用来存放程序和程序处理的数据,由一组动态随机存取存储器(DRAM)组成,是一个线性字节数组*
 * **处理器**： *中央处理单元(CPU),执行存储在主存中存储的引擎,核心是大小为一字的存储设备(或寄存器),称为程序计数器(PC)*
### 目标文件的执行过程(无缓存)
1. CPU执行shell的指令,等待用户输入字符
2. 输入hello.exe(each in 'hello.exe'：USB -> I/O总线 -> I/O桥 -> 系统总线 -> 总线接口 -> 寄存器文件 -> 总线接口 -> 系统总线 -> I/O桥 -> 主存储器)
3. 通过直接存储器读取文件,将hello.exe的代码和数据复制到主存(磁盘控制器 -> I/O桥 -> 内存总线 -> 主存设备)
4. 执行man函数的机器语言指令,将"hello word\n"，从主存复制到寄存器文件，再从寄存器文件复制到显示设备

- > **系统花费大量时间把信息从一个地方挪到另一个地方,减慢了程序的"真正"工作**
- > 根据机械原理：**较大的存储设备要比较小的存储设备运行的慢,而快速设备的造价远高于同类的低速设备**
- > **处理器从寄存器文件中读数据要比从主存中读数据快的多的多**
- > 系统设计者采用了更小更快的存储设备(高速缓存存储器)
### 存储设备结构
1. `L0(寄存器)`：*保存来自高速缓存存储器的字节*
2. `L1(L1高速缓存:SRAM)`：*保存取自L2的高速缓存行*
3. `L2(L2高速缓存:SRAM)`：*保存取自L3的高速缓存行*
4. `L3(L3高速缓存:SRAM)`：*保存取自主存的高速缓存行*
5. `L4(主存)`：*保存取自本地磁盘的磁盘块*
6. `L5(本地二级存储:本地磁盘)`：*保存取自远程服务器上的磁盘文件*
7. `L6(远程二级服务器)`

### 操作系统
 * **防止硬件被失控的应用程序滥用**
 * **向而应用程序提供简单一致的机制来控制低级硬件设备**
 > 操作系统通过进程、虚拟内存、文件来实现以上基本功能
 #### 进程
 - `进程`：**对一个正在运行的程序的抽象**使程序看上去好像独占地使用处理器、主存、I/O设备
 - `上下文`：**操作系统保持跟踪进程运行所需的所有状态信息**这种状态就是上下文
 - `并发运行`：**一个进程的指令和另一个进程的指令是交错执行的**
 - `上下文切换`: **保存当前进程的上下文，恢复新进程的上下文，然后将控制权转给新进程**
 - `系统内核`: **操作系统代码常驻主存部分，是系统管理全部进程所用代码和数据结构的集合**
 > 单核处理器在一个时刻只能执行一个程序，多核处理器同一时刻能执行多个程序
 #### 线程
 `线程`：**一个进程可以由多个线程的执行单元组成，都运行在进程的上下文中，并共享同样的代码和数据结构**
 > Linux中的进程相当于Windows中的线程
 #### 内存
 - `虚拟内存`：**对程序存储器的抽象**
 - `虚拟内存空间地址`：*进程看到的内存都是一致的，由大量准确定义的区构成，每个区都有专门的功能*
 - `物理内存`：**实际上的内存**
 - `物理内存空间地址`：**实际上的RAM内存条的空间**
 - `驻留内存`：**被映射到虚拟内存空间的物理内存**
 - `共享内存`：**被多个进程共享的内存**
  ##### 虚拟内存地址空间(按区分配)
  * **内核虚拟内存** *顶级区域,隐藏*
  * **用户栈** *编译器用它来实现函数调用(每调用一个函数，栈就增长，从一个函数返回时，栈就减少)*
  * **共享库** *存放像C标准库和数学库这样的共享库的代码和数据的区域*
  * **运行时堆** *存放运行时的数据*
  * **程序代码和数据** *进程开始运行时按照可执行目标文件的内容初始化*
  * **0**
  > Linux不共享内核虚拟内存
 #### 文件
 `文件`：**对I/O设备的抽象**
 #### 网络
 `网络`：**可视为一个I/O设备** *当系统从主存复制一串字节到网络适配器时，数据流经过网络到达另一台机器*
 #### Amdahl定律
 `Amdahl定律`：**当对系统的某个部分加速时，对系统整体性能的影响取决于该部分的重要性和加速速度**
 > S = 1 / (1- a) + a/k （a：该部分所需执行时间/系统整体执行时间，k：该部分性能提升比例）
 > 要想显著加速整个系统，必须提升全系统中相当大的部分的速度
 #### 并发和并行
 - `并发`：**同时具有多个活动的系统**
 - `并行`：**并发来使系统运行的更快**
 ##### 线程级并发
  ###### 多核处理器
  > 多核处理器由多个CPU核和L3高速缓存组成，每个核都有自己的L1数据高速缓存、L1指令高速缓存、L2高速缓存
  > 减少了在执行多个任务时模拟并发的需求、当程序以多线程方式编写时线程可以并行地高效执行
 ##### 指令级并行
 - `指令级并行`：**处理器可以同时执行多条指令**
 - `流水线`：**将一条指令所需要的活动分成不同的步骤，将CPU的硬件组织成一系列的阶段，每个阶段执行一个步骤，这些阶段可以并发的操作**
 - `超标量`：**处理器的执行速率达到比一个周期一条指令更快**
 >
 ##### 单指令、多数据并行
 `单指令、多数据并行(SIMD并行)`：**允许一条指令产生多个可并行执行的操作** *大多是为了提高处理影像、声音、视频数据应用的效率*
### 计算机系统的抽象
<table border=1>
   <thead>
     <tr>
       <th colspan="4">虚拟机</th>
     </tr>
   </thead>
   <tbody>
     <tr>
       <td>操作系统</td>
       <td colspan="3">进程</td>
     </tr>
     <tr>
       <td></td>
       <td>指令集架构</td>
       <td colspan="2">虚拟内存</td>
     </tr>
     <tr>
       <td></td>
       <td>处理器</td>
       <td>主存</td>
       <td>文件</td>
     </tr>
     <tr>
       <td colspan="3"></td>
       <td>I/O设备</td>
     </tr>
   </tbody>
 </table>

## 程序结构和执行
### 信息的表示和处理
 * **小端法** *最低有效字节在前面*
 * **大端法** *最低有效字节在后面*
 **浮点数保存**
 ```
 -6.625
 = -( 1 *2^2 + 1 *2^1 + 0 *2^0 + 1 *2^-1 + 0 *2^-2 + 1 *2^-3 )
 = -( 110.101) 【二进制表示】
 = -(1.10101) * 2 ^ 2【二进制表示】
 = 1 127 + 2 10101 000000000000000000
 = 1 10000001 10101 000000000000000000
 ```
 > 第一位，表示符号位，代表正负。
 > 第二到九位，表示指数位，值为127 + [浮点数二进制科学记数法2的指数]。
 > 第十到第32位，表示浮点位， [浮点数二进制科学记数法小数位右补0]。
### 存储器层次结构
 #### 易失性存储器
  * 只要有电SRAM就会保持不变，DRAM需要刷新(如果漏电,DRAM单元会在10~100毫秒内失去电荷,内存系统必须周期的读出,然后重写来刷新每一位)，SRAM的存取比DRAM快约10倍，代价是SRAM单元比DRAM单元使用更多晶体管，密集度低，更贵，功率更大
 #### 非易失性存储器
 * PROM(可编程ROM)只能被编程一次
 * EPROM(可擦写ROM)被擦除和重编程达1000次
 * EEPROM(电子可擦写ROM)类似EPROM，可印在电路卡上编程
 * flash memory(闪存)基于EEPROM
 * SSD(固态硬盘)基于闪存的磁盘驱动器
 * 磁盘由盘片构成，一个盘片由两个表面，每个表面由一级磁道的同心圆组成，每个磁道被分为一组扇区，扇区由一组间隔分开，间隔用来标识格式化位

 | 类型 | 缓存内容 | 缓存位置 | 延迟(周期数) | 由谁管理 |
 |------|---------|---------|-------------|----------|
 | CPU寄存器 | 4或8字节 | 芯片上的CPU寄存器 | 0 | 编译器 |
 | TLB | 地址翻译 | 芯片上的TLB | 0 | 硬件MMU |
 | L1高速缓存 | 64字节块 | 芯片上的L1的高速缓存 | 4 | 硬件 |
 | L2高速缓存 | 64字节块 | 芯片上的L2的高速缓存 | 10 | 硬件 |
 | L3高速缓存 | 64字节块 | 芯片上的L3的高速缓存 | 50 | 硬件 |
 | 虚拟内存 | 4KB页 | 主存 | 200 | 硬件 + OS |
 | 缓冲区缓存 | 部分文件 | 主存 | 200 | OS |
 | 磁盘缓存 | 硬盘扇区 | 磁盘控制器 | 100 000 | 控制器固件 |
 | 网络缓存 | 部分文件 | 本地磁盘 | 10 000 000 | NFS客户 |

## 在系统上运行程序
### 虚拟内存
> 虚拟内存被组织成N个连续的字节大小的单元组成的数组，每字节都有唯一的虚拟地址，作为数组的索引。VM系统将虚拟内存分割为虚拟页的大小固定的块，物理内存也被分为物理页。
> 物理页缓存在L1、L2、L3中，虚拟页缓存在主存中。
* `页表`：页表条目的数组用于将虚拟页映射到物理页
* `缺页`：读写取虚拟内存时，DRAM不命中，触发缺页异常，调用内核异常处理程序，选择一个牺牲页，更新该页，重启导致缺页的命令
* **每当CPU产生一个虚拟地址，MMU就必须查阅一个PTE，以便将虚拟地址翻译为物理地址**
* `碎片`：虽然有未使用的内存，但不能满足分配请求
* `内部碎片`：已分配块大小和它们的有效载荷大小之差的和
* `外部碎片`：当空闲内存合计可满足分配请求，但没有一个内存块足够大可以处理这个请求
* `空闲链表`：大多数分配器将边界、是否已分配的信息嵌入块本身，空闲块通过头部中的大小字段隐含连接
> **以下使用DRAM表示常驻内存的页表**
* `CPU访问主存`：*CPU提供虚拟内存地址，通过地址翻译来定位DRAM中的列表条目，如果不命中(也叫缺页)则触发缺页异常，调用内核异常处理程序，选择一个牺牲页，更新该页并重启导致缺页的命令，命中列表条目，得到物理地址*
> 操作系统为每个进程提供了独立的页面也就是提供了独立的虚拟地址空间
* `共享物理页面`：*被多个虚拟地址空间映射*

### 系统级I/O
### 网络编程
### 并发编程
